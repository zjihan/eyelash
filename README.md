# eyelash: readme

How we built our code: 
First of all, we set up numerous variables, of which the most prominent are backdrive, steerangle, wall, and turns.
We have our backdrive which powers the back motor at port D on and off. We also have our steerangle which controls the angle at which the Ackermann steering motor turns, while the wall variable stores either one or zero; one meaning that the robot is placed on the map such that the outer wall is on its right side, and zero meaning that the outer wall is on its left. This is stored for future use for the purpose of streamlining our code. The turns variable counts the number of turns the robot has made. This not only counts the number of laps, where one lap equals four turns, but also provides a benchmark which is used for ensuring the robot does not go off-track, which we will be elaborating on later in the report. 

As we are using block coding, I will be explaining the flow of our code in a graphical manner, from one branch to another. We have a total of four branches in our code, of which the fourth is a work in progress because we are still refining the details of the code.

In the first main branch, we have a block that resets the steering motor. Backdrive one means that the back motor is turned on. Steerangle zero tells the robot to lock steering to 0 degrees. 
This is then followed by a loop, containing the formula (a-b)*c, which is our threshold, twenty five, minus the reading of the right ultrasonic sensor value multiplied by our constant one, which determines the magnitude of the turns. We decided that the value one is appropriate because it is relatively accurate and smooth, thus we did not change the value of the constant. The purpose of this calculation is to ensure the bot is constantly twenty five centimeters away from either the inner or outer wall. We will likely incorporate the use of the wall variable, which was previously mentioned, to make this code more accurate if necessary before the competition. This loop continues until the front ultrasonic sensor measures that the robot is forty centimeters away from the outer wall. Next, in order to determine when the robot should turn, we compared the values of the left ultrasonic sensor and the right ultrasonic sensor. If the value that the left ultrasonic sensor reads is more than that of the right ultrasonic sensor, we then conclude that the outer wall is on the right side of the robot and vice versa. This then triggers the robot to turn as it has reached the point past the inner wall. Our Ackermann drive makes the programming of the turn very easy since the steering is controlled by a single motor. After the turn, we set a cool-down period of two point two five seconds in order for the robot to complete its turn. After the turn is completed, we then reset the value of the steering and lock the steering motor at an angle of zero degrees for the robot to continue moving straight. After the steering has been adjusted back to zero degrees, we then repeat the process for two more laps. 

Next, our second branch is an infinite loop. Again, we use the equation (a-b)*c, where b is the value of the front steering motor, a is the desired steer angle, and c is our constant parameter of two. We chose two because it is the appropriate value that is required in order for the robot to turn according to our needs. The final value that is derived from the equation is then programmed into the front steering motor using the “On” mechanism. 

Our third branch is also an infinite loop. When Backdrive is equals to one, then turn on the back motor to speed if not then brake. This allows us to control the back motor by simply writing and updating our variable rather than programming it into the motor block and having to check ports each time. This reduces carelessness. By moving the motor at a constant speed, it ensures the accuracy of our turning. 

The fourth branch also utilizes the Infinite loop function. After waiting for the motor rotation to be ninety degrees, add one to the number of turns. The turns variable acts as a counter that we can refer to for various uses later on. Every recorded ninety degrees, the angle of the steering motor is reset so we can take its readings again. Then, we compare the total angle that the robot turned to the angle that it should have turned. We take the number of turns multiplied by ninety, which is how much it should have turned exactly. We then compare it with a reading from our gyro sensor, and if they are not equal, we get the robot to reverse so that it does not get stuck inside the map. 

As for building, compiling and uploading of code to the vehicle’s controllers:
EV3G creates great programs that are smooth for our EV3 brick, motors and sensors. When EV3 is paired with EV3G, it provides us with unparalleled accessibility. EV3G has a variety of blocks for different components like motors, sensors and more. It also comes with a wide range of flexibility through custom features like variables et cetera.
